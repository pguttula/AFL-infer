Found 212 issues

crypto_stream/salsa2012/ref/stream_salsa2012_ref.c:30: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `in` `of size 16` could be accessed with an index out of bounds at line 30, column 9.
  28.       }
  29.       for (i = 0; i < 8; ++i) {
  30. >         in[i] = n[i];
  31.       }
  32.       for (i = 8; i < 16; ++i) {

crypto_stream/salsa2012/ref/stream_salsa2012_ref.c:27: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `kcopy` `of size 32` could be accessed with an index out of bounds at line 27, column 9.
  25.       }
  26.       for (i = 0; i < 32; ++i) {
  27. >         kcopy[i] = k[i];
  28.       }
  29.       for (i = 0; i < 8; ++i) {

crypto_stream/salsa208/ref/stream_salsa208_ref.c:30: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `in` `of size 16` could be accessed with an index out of bounds at line 30, column 9.
  28.       }
  29.       for (i = 0; i < 8; ++i) {
  30. >         in[i] = n[i];
  31.       }
  32.       for (i = 8; i < 16; ++i) {

crypto_stream/salsa208/ref/stream_salsa208_ref.c:27: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `kcopy` `of size 32` could be accessed with an index out of bounds at line 27, column 9.
  25.       }
  26.       for (i = 0; i < 32; ++i) {
  27. >         kcopy[i] = k[i];
  28.       }
  29.       for (i = 0; i < 8; ++i) {

crypto_onetimeauth/poly1305/donna/poly1305_donna.c:28: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `st->buffer` `of size 16` could be accessed with an index out of bounds at line 28, column 13.
  26.           }
  27.           for (i = 0; i < want; i++) {
  28. >             st->buffer[st->leftover + i] = m[i];
  29.           }
  30.           bytes -= want;

crypto_scalarmult/curve25519/sandy2x/curve25519_sandy2x.c:45: warning: ANALYSIS_STOPS (biabduction/Rearrange.ml:307:38-45:)
  exception: Bad_footprint.
  43.     ladder(var, t);
  44.   
  45. >   z_51.v[0] = (z2[1] << 26) + z2[0];
  46.     z_51.v[1] = (z2[3] << 26) + z2[2];
  47.     z_51.v[2] = (z2[5] << 26) + z2[4];

crypto_scalarmult/curve25519/sandy2x/curve25519_sandy2x.c:45: error: Bad_footprint (biabduction/Rearrange.ml:307:38-45:)
  .
  43.     ladder(var, t);
  44.   
  45. >   z_51.v[0] = (z2[1] << 26) + z2[0];
  46.     z_51.v[1] = (z2[3] << 26) + z2[2];
  47.     z_51.v[2] = (z2[5] << 26) + z2[4];

crypto_pwhash/argon2/argon2.c:68: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  66.        * blocks
  67.        */
  68. >     result = initialize(&instance, context);
  69.   
  70.       if (ARGON2_OK != result) {

crypto_pwhash/argon2/argon2.c:68: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `initialize()` at line 68, column 14.
  66.        * blocks
  67.        */
  68. >     result = initialize(&instance, context);
  69.   
  70.       if (ARGON2_OK != result) {

crypto_generichash/blake2b/ref/blake2b-compress-ref.c:41: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `S->h` `of size 8` could be accessed with an index out of bounds at line 41, column 16.
  39.       }
  40.       for (i = 0; i < 8; ++i) {
  41. >         v[i] = S->h[i];
  42.       }
  43.       v[8]  = blake2b_IV[0];

crypto_generichash/blake2b/ref/blake2b-compress-ref.c:38: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `m` `of size 16` could be accessed with an index out of bounds at line 38, column 9.
  36.   
  37.       for (i = 0; i < 16; ++i) {
  38. >         m[i] = LOAD64_LE(block + i * sizeof(m[i]));
  39.       }
  40.       for (i = 0; i < 8; ++i) {

crypto_generichash/blake2b/ref/blake2b-compress-ref.c:73: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `m` `of size 16` could be accessed with an index out of bounds at line 73, column 5.
  71.           G(r, 7, v[3], v[4], v[9], v[14]);  \
  72.       } while (0)
  73. >     ROUND(0);
  74.       ROUND(1);
  75.       ROUND(2);

crypto_generichash/blake2b/ref/blake2b-compress-ref.c:74: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `m` `of size 16` could be accessed with an index out of bounds at line 74, column 5.
  72.       } while (0)
  73.       ROUND(0);
  74. >     ROUND(1);
  75.       ROUND(2);
  76.       ROUND(3);

crypto_generichash/blake2b/ref/blake2b-compress-ref.c:75: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `m` `of size 16` could be accessed with an index out of bounds at line 75, column 5.
  73.       ROUND(0);
  74.       ROUND(1);
  75. >     ROUND(2);
  76.       ROUND(3);
  77.       ROUND(4);

crypto_sign/ed25519/ref10/obsolete.c:47: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:627:34-41:)
  exception: Cannot_star.
  45.       crypto_hash_sha512_update(&hs, sk + 32, 32);
  46.       crypto_hash_sha512_update(&hs, m, mlen);
  47. >     crypto_hash_sha512_final(&hs, nonce);
  48.       ge25519_scalarmult_base(&A, sk);
  49.       ge25519_p3_tobytes(sig + 32, &A);

crypto_sign/ed25519/ref10/obsolete.c:47: error: Cannot_star (biabduction/Tabulation.ml:627:34-41:)
  .
  45.       crypto_hash_sha512_update(&hs, sk + 32, 32);
  46.       crypto_hash_sha512_update(&hs, m, mlen);
  47. >     crypto_hash_sha512_final(&hs, nonce);
  48.       ge25519_scalarmult_base(&A, sk);
  49.       ge25519_p3_tobytes(sig + 32, &A);

crypto_kx/crypto_kx.c:54: error: Assert_failure (biabduction/SymExec.ml:303:6-6:)
  .
  52.           sodium_misuse(); /* LCOV_EXCL_LINE */
  53.       }
  54. >     if (crypto_scalarmult(q, client_sk, server_pk) != 0) {
  55.           return -1;
  56.       }

crypto_box/curve25519xsalsa20poly1305/box_curve25519xsalsa20poly1305.c:42: error: Assert_failure (biabduction/SymExec.ml:303:6-6:)
  .
  40.       unsigned char s[32];
  41.   
  42. >     if (crypto_scalarmult_curve25519(s, sk, pk) != 0) {
  43.           return -1;
  44.       }

crypto_verify/sodium/verify.c:56: error: DEAD_STORE
  The value written to &v1 (type void) is never used.
  54.       }
  55.       m = _mm_movemask_epi8(_mm_cmpeq_epi32(z, zero));
  56. >     v1 = zero; v2 = zero; z = zero;
  57.   
  58.       return (int) (((uint32_t) m + 1U) >> 16) - 1;

crypto_verify/sodium/verify.c:56: error: DEAD_STORE
  The value written to &v2 (type void) is never used.
  54.       }
  55.       m = _mm_movemask_epi8(_mm_cmpeq_epi32(z, zero));
  56. >     v1 = zero; v2 = zero; z = zero;
  57.   
  58.       return (int) (((uint32_t) m + 1U) >> 16) - 1;

crypto_verify/sodium/verify.c:56: error: DEAD_STORE
  The value written to &z (type void) is never used.
  54.       }
  55.       m = _mm_movemask_epi8(_mm_cmpeq_epi32(z, zero));
  56. >     v1 = zero; v2 = zero; z = zero;
  57.   
  58.       return (int) (((uint32_t) m + 1U) >> 16) - 1;

crypto_auth/hmacsha256/auth_hmacsha256.c:54: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `pad` `of size 64` could be accessed with an index out of bounds at line 54, column 9.
  52.       memset(pad, 0x36, 64);
  53.       for (i = 0; i < keylen; i++) {
  54. >         pad[i] ^= key[i];
  55.       }
  56.       crypto_hash_sha256_update(&state->ictx, pad, 64);

crypto_auth/hmacsha256/auth_hmacsha256.c:61: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `pad` `of size 64` could be accessed with an index out of bounds at line 61, column 9.
  59.       memset(pad, 0x5c, 64);
  60.       for (i = 0; i < keylen; i++) {
  61. >         pad[i] ^= key[i];
  62.       }
  63.       crypto_hash_sha256_update(&state->octx, pad, 64);

crypto_auth/hmacsha256/auth_hmacsha256.c:54: error: Bad_footprint (biabduction/Rearrange.ml:307:38-45:)
  .
  52.       memset(pad, 0x36, 64);
  53.       for (i = 0; i < keylen; i++) {
  54. >         pad[i] ^= key[i];
  55.       }
  56.       crypto_hash_sha256_update(&state->ictx, pad, 64);

crypto_auth/hmacsha512/auth_hmacsha512.c:54: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `pad` `of size 128` could be accessed with an index out of bounds at line 54, column 9.
  52.       memset(pad, 0x36, 128);
  53.       for (i = 0; i < keylen; i++) {
  54. >         pad[i] ^= key[i];
  55.       }
  56.       crypto_hash_sha512_update(&state->ictx, pad, 128);

crypto_auth/hmacsha512/auth_hmacsha512.c:61: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `pad` `of size 128` could be accessed with an index out of bounds at line 61, column 9.
  59.       memset(pad, 0x5c, 128);
  60.       for (i = 0; i < keylen; i++) {
  61. >         pad[i] ^= key[i];
  62.       }
  63.       crypto_hash_sha512_update(&state->octx, pad, 128);

crypto_pwhash/argon2/argon2-fill-block-ssse3.c:62: error: UNINITIALIZED_VALUE
  The value read from block_XY.[_] was never initialized.
  60.   
  61.       for (i = 0; i < ARGON2_OWORDS_IN_BLOCK; i++) {
  62. >         state[i] = _mm_xor_si128(state[i], block_XY[i]);
  63.           _mm_storeu_si128((__m128i *) (&next_block[16 * i]), state[i]);
  64.       }

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:42: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 42, column 5.
  40.   salsa_keysetup(salsa_ctx *ctx, const uint8_t *k)
  41.   {
  42. >     ctx->input[TR[1]]  = LOAD32_LE(k + 0);
  43.       ctx->input[TR[2]]  = LOAD32_LE(k + 4);
  44.       ctx->input[TR[3]]  = LOAD32_LE(k + 8);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:43: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 43, column 5.
  41.   {
  42.       ctx->input[TR[1]]  = LOAD32_LE(k + 0);
  43. >     ctx->input[TR[2]]  = LOAD32_LE(k + 4);
  44.       ctx->input[TR[3]]  = LOAD32_LE(k + 8);
  45.       ctx->input[TR[4]]  = LOAD32_LE(k + 12);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:44: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 44, column 5.
  42.       ctx->input[TR[1]]  = LOAD32_LE(k + 0);
  43.       ctx->input[TR[2]]  = LOAD32_LE(k + 4);
  44. >     ctx->input[TR[3]]  = LOAD32_LE(k + 8);
  45.       ctx->input[TR[4]]  = LOAD32_LE(k + 12);
  46.       ctx->input[TR[11]] = LOAD32_LE(k + 16);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:45: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 45, column 5.
  43.       ctx->input[TR[2]]  = LOAD32_LE(k + 4);
  44.       ctx->input[TR[3]]  = LOAD32_LE(k + 8);
  45. >     ctx->input[TR[4]]  = LOAD32_LE(k + 12);
  46.       ctx->input[TR[11]] = LOAD32_LE(k + 16);
  47.       ctx->input[TR[12]] = LOAD32_LE(k + 20);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:46: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 46, column 5.
  44.       ctx->input[TR[3]]  = LOAD32_LE(k + 8);
  45.       ctx->input[TR[4]]  = LOAD32_LE(k + 12);
  46. >     ctx->input[TR[11]] = LOAD32_LE(k + 16);
  47.       ctx->input[TR[12]] = LOAD32_LE(k + 20);
  48.       ctx->input[TR[13]] = LOAD32_LE(k + 24);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:47: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 47, column 5.
  45.       ctx->input[TR[4]]  = LOAD32_LE(k + 12);
  46.       ctx->input[TR[11]] = LOAD32_LE(k + 16);
  47. >     ctx->input[TR[12]] = LOAD32_LE(k + 20);
  48.       ctx->input[TR[13]] = LOAD32_LE(k + 24);
  49.       ctx->input[TR[14]] = LOAD32_LE(k + 28);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:48: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 48, column 5.
  46.       ctx->input[TR[11]] = LOAD32_LE(k + 16);
  47.       ctx->input[TR[12]] = LOAD32_LE(k + 20);
  48. >     ctx->input[TR[13]] = LOAD32_LE(k + 24);
  49.       ctx->input[TR[14]] = LOAD32_LE(k + 28);
  50.       ctx->input[TR[0]]  = 0x61707865;

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:49: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 49, column 5.
  47.       ctx->input[TR[12]] = LOAD32_LE(k + 20);
  48.       ctx->input[TR[13]] = LOAD32_LE(k + 24);
  49. >     ctx->input[TR[14]] = LOAD32_LE(k + 28);
  50.       ctx->input[TR[0]]  = 0x61707865;
  51.       ctx->input[TR[5]]  = 0x3320646e;

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:50: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 50, column 5.
  48.       ctx->input[TR[13]] = LOAD32_LE(k + 24);
  49.       ctx->input[TR[14]] = LOAD32_LE(k + 28);
  50. >     ctx->input[TR[0]]  = 0x61707865;
  51.       ctx->input[TR[5]]  = 0x3320646e;
  52.       ctx->input[TR[10]] = 0x79622d32;

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:51: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 51, column 5.
  49.       ctx->input[TR[14]] = LOAD32_LE(k + 28);
  50.       ctx->input[TR[0]]  = 0x61707865;
  51. >     ctx->input[TR[5]]  = 0x3320646e;
  52.       ctx->input[TR[10]] = 0x79622d32;
  53.       ctx->input[TR[15]] = 0x6b206574;

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:52: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 52, column 5.
  50.       ctx->input[TR[0]]  = 0x61707865;
  51.       ctx->input[TR[5]]  = 0x3320646e;
  52. >     ctx->input[TR[10]] = 0x79622d32;
  53.       ctx->input[TR[15]] = 0x6b206574;
  54.   }

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:53: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 53, column 5.
  51.       ctx->input[TR[5]]  = 0x3320646e;
  52.       ctx->input[TR[10]] = 0x79622d32;
  53. >     ctx->input[TR[15]] = 0x6b206574;
  54.   }
  55.   

crypto_box/curve25519xchacha20poly1305/box_curve25519xchacha20poly1305.c:48: error: Assert_failure (biabduction/SymExec.ml:303:6-6:)
  .
  46.       unsigned char s[32];
  47.   
  48. >     if (crypto_scalarmult_curve25519(s, sk, pk) != 0) {
  49.           return -1;
  50.       }

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:52: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `src->d` `of size 8` could be accessed with an index out of bounds at line 52, column 22.
  50.   #else
  51.       for (i = 0; i < 8; ++i) {
  52. >         dest->d[i] = src->d[i];
  53.       }
  54.   #endif

crypto_pwhash/argon2/argon2-fill-block-avx2.c:65: error: UNINITIALIZED_VALUE
  The value read from block_XY.[_] was never initialized.
  63.   
  64.       for (i = 0; i < ARGON2_HWORDS_IN_BLOCK; i++) {
  65. >         state[i] = _mm256_xor_si256(state[i], block_XY[i]);
  66.           _mm256_storeu_si256((__m256i *) (&next_block[32 * i]), state[i]);
  67.       }

crypto_pwhash/argon2/argon2-fill-block-avx512f.c:68: error: UNINITIALIZED_VALUE
  The value read from block_XY.[_] was never initialized.
  66.   
  67.       for (i = 0; i < ARGON2_512BIT_WORDS_IN_BLOCK; i++) {
  68. >         state[i] = _mm512_xor_si512(state[i], block_XY[i]);
  69.           _mm512_storeu_si512((__m512i *) (&next_block[64 * i]), state[i]);
  70.       }

crypto_sign/ed25519/ref10/keypair.c:63: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  61.       }
  62.       fe25519_1(one_minus_y);
  63. >     fe25519_sub(one_minus_y, one_minus_y, A.Y);
  64.       fe25519_invert(one_minus_y, one_minus_y);
  65.       fe25519_1(x);

crypto_sign/ed25519/ref10/keypair.c:63: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_sub()` at line 63, column 5.
  61.       }
  62.       fe25519_1(one_minus_y);
  63. >     fe25519_sub(one_minus_y, one_minus_y, A.Y);
  64.       fe25519_invert(one_minus_y, one_minus_y);
  65.       fe25519_1(x);

crypto_scalarmult/curve25519/ref10/x25519_ref10.c:94: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  92.           fe25519_sub(tmp0, x3, z3);
  93.           fe25519_sub(tmp1, x2, z2);
  94. >         fe25519_add(x2, x2, z2);
  95.           fe25519_add(z2, x3, z3);
  96.           fe25519_mul(z3, tmp0, x2);

crypto_scalarmult/curve25519/ref10/x25519_ref10.c:94: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_add()` at line 94, column 9.
  92.           fe25519_sub(tmp0, x3, z3);
  93.           fe25519_sub(tmp1, x2, z2);
  94. >         fe25519_add(x2, x2, z2);
  95.           fe25519_add(z2, x3, z3);
  96.           fe25519_mul(z3, tmp0, x2);

crypto_core/ed25519/ref10/ed25519_ref10.c:64: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  62.       fe25519_sq(t0, z);
  63.       fe25519_sq(t1, t0);
  64. >     fe25519_sq(t1, t1);
  65.       fe25519_mul(t1, z, t1);
  66.       fe25519_mul(t0, t0, t1);

crypto_core/ed25519/ref10/ed25519_ref10.c:64: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_sq()` at line 64, column 5.
  62.       fe25519_sq(t0, z);
  63.       fe25519_sq(t1, t0);
  64. >     fe25519_sq(t1, t1);
  65.       fe25519_mul(t1, z, t1);
  66.       fe25519_mul(t0, t0, t1);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:59: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 59, column 5.
  57.   salsa_ivsetup(salsa_ctx *ctx, const uint8_t *iv, const uint8_t *counter)
  58.   {
  59. >     ctx->input[TR[6]] = LOAD32_LE(iv + 0);
  60.       ctx->input[TR[7]] = LOAD32_LE(iv + 4);
  61.       ctx->input[TR[8]] = counter == NULL ? 0 : LOAD32_LE(counter + 0);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:60: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 60, column 5.
  58.   {
  59.       ctx->input[TR[6]] = LOAD32_LE(iv + 0);
  60. >     ctx->input[TR[7]] = LOAD32_LE(iv + 4);
  61.       ctx->input[TR[8]] = counter == NULL ? 0 : LOAD32_LE(counter + 0);
  62.       ctx->input[TR[9]] = counter == NULL ? 0 : LOAD32_LE(counter + 4);

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:61: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 61, column 5.
  59.       ctx->input[TR[6]] = LOAD32_LE(iv + 0);
  60.       ctx->input[TR[7]] = LOAD32_LE(iv + 4);
  61. >     ctx->input[TR[8]] = counter == NULL ? 0 : LOAD32_LE(counter + 0);
  62.       ctx->input[TR[9]] = counter == NULL ? 0 : LOAD32_LE(counter + 4);
  63.   }

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:62: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `ctx->input` `of size 16` could be accessed with an index out of bounds at line 62, column 5.
  60.       ctx->input[TR[7]] = LOAD32_LE(iv + 4);
  61.       ctx->input[TR[8]] = counter == NULL ? 0 : LOAD32_LE(counter + 0);
  62. >     ctx->input[TR[9]] = counter == NULL ? 0 : LOAD32_LE(counter + 4);
  63.   }
  64.   

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:68: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `src->d` `of size 8` could be accessed with an index out of bounds at line 68, column 23.
  66.   #else
  67.       for (i = 0; i < 8; ++i) {
  68. >         dest->d[i] ^= src->d[i];
  69.       }
  70.   #endif

crypto_stream/salsa2012/ref/stream_salsa2012_ref.c:76: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `in` `of size 16` could be accessed with an index out of bounds at line 76, column 9.
  74.       }
  75.       for (i = 0; i < 8; ++i) {
  76. >         in[i] = n[i];
  77.       }
  78.       for (i = 8; i < 16; ++i) {

crypto_stream/salsa2012/ref/stream_salsa2012_ref.c:73: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `kcopy` `of size 32` could be accessed with an index out of bounds at line 73, column 9.
  71.       }
  72.       for (i = 0; i < 32; ++i) {
  73. >         kcopy[i] = k[i];
  74.       }
  75.       for (i = 0; i < 8; ++i) {

crypto_stream/salsa208/ref/stream_salsa208_ref.c:76: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `in` `of size 16` could be accessed with an index out of bounds at line 76, column 9.
  74.       }
  75.       for (i = 0; i < 8; ++i) {
  76. >         in[i] = n[i];
  77.       }
  78.       for (i = 8; i < 16; ++i) {

crypto_stream/salsa208/ref/stream_salsa208_ref.c:73: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `kcopy` `of size 32` could be accessed with an index out of bounds at line 73, column 9.
  71.       }
  72.       for (i = 0; i < 32; ++i) {
  73. >         kcopy[i] = k[i];
  74.       }
  75.       for (i = 0; i < 8; ++i) {

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:96: error: DEAD_STORE
  The value written to &i (type int) is never used.
  94.       EXPAND_KEY_1(0x10); EXPAND_KEY_2(0x10);
  95.       EXPAND_KEY_1(0x20); EXPAND_KEY_2(0x20);
  96. >     EXPAND_KEY_1(0x40);
  97.   }
  98.   

crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:204: error: DEAD_STORE
  The value written to &c (type unsigned char*) is never used.


crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:185: error: DEAD_STORE
  The value written to &diag3 (type void) is never used.


crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:190: error: DEAD_STORE
  The value written to &diag3 (type void) is never used.


crypto_stream/salsa20/xmm6int/salsa20_xmm6int-avx2.c:205: error: DEAD_STORE
  The value written to &m (type unsigned char const *) is never used.


crypto_stream/chacha20/dolbeau/chacha20_dolbeau-ssse3.c:4: error: DEAD_STORE
  The value written to &rot16 (type int) is never used.
  2.   #include <stdint.h>
  3.   #include <stdlib.h>
  4. > #include <string.h>
  5.   
  6.   #include "core.h"

crypto_stream/chacha20/dolbeau/chacha20_dolbeau-ssse3.c:4: error: DEAD_STORE
  The value written to &rot16 (type int) is never used.
  2.   #include <stdint.h>
  3.   #include <stdlib.h>
  4. > #include <string.h>
  5.   
  6.   #include "core.h"

crypto_stream/chacha20/dolbeau/chacha20_dolbeau-ssse3.c:6: error: DEAD_STORE
  The value written to &rot8 (type int) is never used.
  4.   #include <string.h>
  5.   
  6. > #include "core.h"
  7.   #include "crypto_stream_chacha20.h"
  8.   #include "private/common.h"

crypto_stream/chacha20/dolbeau/chacha20_dolbeau-ssse3.c:6: error: DEAD_STORE
  The value written to &rot8 (type int) is never used.
  4.   #include <string.h>
  5.   
  6. > #include "core.h"
  7.   #include "crypto_stream_chacha20.h"
  8.   #include "private/common.h"

crypto_pwhash/argon2/argon2-fill-block-ssse3.c:94: error: UNINITIALIZED_VALUE
  The value read from block_XY.[_] was never initialized.
  92.   
  93.       for (i = 0; i < ARGON2_OWORDS_IN_BLOCK; i++) {
  94. >         state[i] = _mm_xor_si128(state[i], block_XY[i]);
  95.           _mm_storeu_si128((__m128i *) (&next_block[16 * i]), state[i]);
  96.       }

crypto_pwhash/argon2/argon2-fill-block-avx2.c:95: error: UNINITIALIZED_VALUE
  The value read from block_XY.[_] was never initialized.
  93.   
  94.       for (i = 0; i < ARGON2_HWORDS_IN_BLOCK; i++) {
  95. >         state[i] = _mm256_xor_si256(state[i], block_XY[i]);
  96.           _mm256_storeu_si256((__m256i *) (&next_block[32 * i]), state[i]);
  97.       }

crypto_scalarmult/curve25519/sandy2x/curve25519_sandy2x.c:89: warning: ANALYSIS_STOPS (biabduction/Rearrange.ml:307:38-45:)
  exception: Bad_footprint.
  87.     ladder_base(var, t);
  88.   
  89. >   z_51.v[0] = (z2[1] << 26) + z2[0];
  90.     z_51.v[1] = (z2[3] << 26) + z2[2];
  91.     z_51.v[2] = (z2[5] << 26) + z2[4];

crypto_scalarmult/curve25519/sandy2x/curve25519_sandy2x.c:89: error: Bad_footprint (biabduction/Rearrange.ml:307:38-45:)
  .
  87.     ladder_base(var, t);
  88.   
  89. >   z_51.v[0] = (z2[1] << 26) + z2[0];
  90.     z_51.v[1] = (z2[3] << 26) + z2[2];
  91.     z_51.v[2] = (z2[5] << 26) + z2[4];

crypto_stream/chacha20/dolbeau/chacha20_dolbeau-avx2.c:4: error: DEAD_STORE
  The value written to &rot16 (type int) is never used.
  2.   #include <stdint.h>
  3.   #include <stdlib.h>
  4. > #include <string.h>
  5.   
  6.   #include "core.h"

crypto_stream/chacha20/dolbeau/chacha20_dolbeau-avx2.c:4: error: DEAD_STORE
  The value written to &rot16 (type int) is never used.
  2.   #include <stdint.h>
  3.   #include <stdlib.h>
  4. > #include <string.h>
  5.   
  6.   #include "core.h"

crypto_stream/chacha20/dolbeau/chacha20_dolbeau-avx2.c:6: error: DEAD_STORE
  The value written to &rot8 (type int) is never used.
  4.   #include <string.h>
  5.   
  6. > #include "core.h"
  7.   #include "crypto_stream_chacha20.h"
  8.   #include "private/common.h"

crypto_stream/chacha20/dolbeau/chacha20_dolbeau-avx2.c:6: error: DEAD_STORE
  The value written to &rot8 (type int) is never used.
  4.   #include <string.h>
  5.   
  6. > #include "core.h"
  7.   #include "crypto_stream_chacha20.h"
  8.   #include "private/common.h"

crypto_pwhash/argon2/argon2-fill-block-avx512f.c:100: error: UNINITIALIZED_VALUE
  The value read from block_XY.[_] was never initialized.
  98.   
  99.       for (i = 0; i < ARGON2_512BIT_WORDS_IN_BLOCK; i++) {
  100. >         state[i] = _mm512_xor_si512(state[i], block_XY[i]);
  101.           _mm512_storeu_si512((__m512i *) (&next_block[64 * i]), state[i]);
  102.       }

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:86: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `dest->d` `of size 8` could be accessed with an index out of bounds at line 86, column 9.
  84.       L = (len >> 3);
  85.       for (i = 0; i < L; ++i) {
  86. >         dest->d[i] = src->d[i];
  87.       }
  88.   #endif

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:86: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `src->d` `of size 8` could be accessed with an index out of bounds at line 86, column 22.
  84.       L = (len >> 3);
  85.       for (i = 0; i < L; ++i) {
  86. >         dest->d[i] = src->d[i];
  87.       }
  88.   #endif

crypto_sign/ed25519/ref10/keypair.c:84: warning: ANALYSIS_STOPS (biabduction/Rearrange.ml:307:38-45:)
  exception: Bad_footprint.
  82.       crypto_hash_sha512(h, ed25519_sk, 32);
  83.   #endif
  84. >     h[0] &= 248;
  85.       h[31] &= 127;
  86.       h[31] |= 64;

crypto_sign/ed25519/ref10/keypair.c:84: error: Bad_footprint (biabduction/Rearrange.ml:307:38-45:)
  .
  82.       crypto_hash_sha512(h, ed25519_sk, 32);
  83.   #endif
  84. >     h[0] &= 248;
  85.       h[31] &= 127;
  86.       h[31] |= 64;

crypto_kx/crypto_kx.c:95: error: Assert_failure (biabduction/SymExec.ml:303:6-6:)
  .
  93.           sodium_misuse(); /* LCOV_EXCL_LINE */
  94.       }
  95. >     if (crypto_scalarmult(q, server_sk, client_pk) != 0) {
  96.           return -1;
  97.       }

crypto_pwhash/argon2/argon2-core.h:85: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `src->v` `of size 128` could be accessed with an index out of bounds at line 85, column 22.
  83.       int i;
  84.       for (i = 0; i < ARGON2_QWORDS_IN_BLOCK; ++i) {
  85. >         dst->v[i] ^= src->v[i];
  86.       }
  87.   }

crypto_stream/chacha20/ref/chacha20_ref.c:119: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `tmp` `of size 64` could be accessed with an index out of bounds at line 119, column 17.
  117.               memset(tmp, 0, 64);
  118.               for (i = 0; i < bytes; ++i) {
  119. >                 tmp[i] = m[i];
  120.               }
  121.               m       = tmp;

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:104: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `dest->d` `of size 8` could be accessed with an index out of bounds at line 104, column 9.
  102.       L = (len >> 3);
  103.       for (i = 0; i < L; ++i) {
  104. >         dest->d[i] ^= src->d[i];
  105.       }
  106.   #endif

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:104: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `src->d` `of size 8` could be accessed with an index out of bounds at line 104, column 23.
  102.       L = (len >> 3);
  103.       for (i = 0; i < L; ++i) {
  104. >         dest->d[i] ^= src->d[i];
  105.       }
  106.   #endif

crypto_pwhash/argon2/argon2-fill-block-ssse3.c:123: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `memset()` at line 123, column 17.
  121.                   __m128i zero2_block[ARGON2_OWORDS_IN_BLOCK];
  122.   
  123. >                 memset(zero_block, 0, sizeof(zero_block));
  124.                   memset(zero2_block, 0, sizeof(zero2_block));
  125.                   init_block_value(&address_block, 0);

crypto_pwhash/argon2/argon2-fill-block-avx2.c:124: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `memset()` at line 124, column 17.
  122.                   __m256i zero2_block[ARGON2_HWORDS_IN_BLOCK];
  123.   
  124. >                 memset(zero_block, 0, sizeof(zero_block));
  125.                   memset(zero2_block, 0, sizeof(zero2_block));
  126.                   init_block_value(&address_block, 0);

crypto_pwhash/argon2/argon2-fill-block-avx512f.c:129: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `memset()` at line 129, column 17.
  127.                   __m512i zero2_block[ARGON2_512BIT_WORDS_IN_BLOCK];
  128.   
  129. >                 memset(zero_block, 0, sizeof(zero_block));
  130.                   memset(zero2_block, 0, sizeof(zero2_block));
  131.                   init_block_value(&address_block, 0);

crypto_pwhash/scryptsalsa208sha256/crypto_scrypt-common.c:129: error: Assert_failure (biabduction/Absarray.ml:579:2-2:)
  .
  127.       }
  128.   
  129. >     src = decode64_uint32(p_p, 30, src);
  130.       if (!src) {
  131.           return NULL;

crypto_core/ed25519/ref10/ed25519_ref10.c:121: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  119.       fe25519_sq(t0, z);
  120.       fe25519_sq(t1, t0);
  121. >     fe25519_sq(t1, t1);
  122.       fe25519_mul(t1, z, t1);
  123.       fe25519_mul(t0, t0, t1);

crypto_core/ed25519/ref10/ed25519_ref10.c:121: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_sq()` at line 121, column 5.
  119.       fe25519_sq(t0, z);
  120.       fe25519_sq(t1, t0);
  121. >     fe25519_sq(t1, t1);
  122.       fe25519_mul(t1, z, t1);
  123.       fe25519_mul(t0, t0, t1);

crypto_pwhash/argon2/argon2-fill-block-ref.c:138: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `address_block.v` `of size 128` could be accessed with an index out of bounds at line 138, column 31.
  136.               }
  137.   
  138. >             pseudo_rands[i] = address_block.v[i % ARGON2_ADDRESSES_IN_BLOCK];
  139.           }
  140.       }

sodium/runtime.c:119: error: UNINITIALIZED_VALUE
  The value read from cpu_info.[_] was never initialized.
  117.   
  118.       _cpuid(cpu_info, 0x0);
  119. >     if ((id = cpu_info[0]) == 0U) {
  120.           return -1; /* LCOV_EXCL_LINE */
  121.       }

crypto_generichash/blake2b/ref/blake2b-ref.c:135: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  133.       P->fanout        = 1;
  134.       P->depth         = 1;
  135. >     STORE32_LE(P->leaf_length, 0);
  136.       STORE64_LE(P->node_offset, 0);
  137.       P->node_depth   = 0;

crypto_generichash/blake2b/ref/blake2b-ref.c:135: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `store32_le()` at line 135, column 5.
  133.       P->fanout        = 1;
  134.       P->depth         = 1;
  135. >     STORE32_LE(P->leaf_length, 0);
  136.       STORE64_LE(P->node_offset, 0);
  137.       P->node_depth   = 0;

crypto_generichash/blake2b/ref/blake2b-ref.c:135: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  133.       P->fanout        = 1;
  134.       P->depth         = 1;
  135. >     STORE32_LE(P->leaf_length, 0);
  136.       STORE64_LE(P->node_offset, 0);
  137.       P->node_depth   = 0;

crypto_onetimeauth/poly1305/donna/poly1305_donna64.h:219: warning: ANALYSIS_STOPS (biabduction/Absarray.ml:75:6-6:)
  exception: Assert_failure.
  217.   
  218.       /* zero out the state */
  219. >     sodium_memzero((void *) st, sizeof *st);
  220.   }

crypto_onetimeauth/poly1305/donna/poly1305_donna64.h:146: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `st->buffer` `of size 16` could be accessed with an index out of bounds at line 146, column 9.
  144.           unsigned long long i = st->leftover;
  145.   
  146. >         st->buffer[i] = 1;
  147.   
  148.           for (i = i + 1; i < poly1305_block_size; i++) {

crypto_onetimeauth/poly1305/donna/poly1305_donna64.h:149: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `st->buffer` `of size 16` could be accessed with an index out of bounds at line 149, column 13.
  147.   
  148.           for (i = i + 1; i < poly1305_block_size; i++) {
  149. >             st->buffer[i] = 0;
  150.           }
  151.           st->final = 1;

crypto_onetimeauth/poly1305/donna/poly1305_donna64.h:219: error: Assert_failure (biabduction/Absarray.ml:75:6-6:)
  .
  217.   
  218.       /* zero out the state */
  219. >     sodium_memzero((void *) st, sizeof *st);
  220.   }

crypto_pwhash/argon2/argon2-fill-block-ssse3.c:189: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `memcpy()` at line 189, column 5.
  187.       }
  188.   
  189. >     memcpy(state, ((instance->region->memory + prev_offset)->v),
  190.              ARGON2_BLOCK_SIZE);
  191.   

crypto_pwhash/argon2/argon2-fill-block-avx2.c:190: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `memcpy()` at line 190, column 5.
  188.       }
  189.   
  190. >     memcpy(state, ((instance->region->memory + prev_offset)->v),
  191.              ARGON2_BLOCK_SIZE);
  192.   

crypto_generichash/blake2b/ref/blake2b-ref.c:158: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  156.       P->fanout        = 1;
  157.       P->depth         = 1;
  158. >     STORE32_LE(P->leaf_length, 0);
  159.       STORE64_LE(P->node_offset, 0);
  160.       P->node_depth   = 0;

crypto_generichash/blake2b/ref/blake2b-ref.c:158: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `store32_le()` at line 158, column 5.
  156.       P->fanout        = 1;
  157.       P->depth         = 1;
  158. >     STORE32_LE(P->leaf_length, 0);
  159.       STORE64_LE(P->node_offset, 0);
  160.       P->node_depth   = 0;

crypto_generichash/blake2b/ref/blake2b-ref.c:158: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  156.       P->fanout        = 1;
  157.       P->depth         = 1;
  158. >     STORE32_LE(P->leaf_length, 0);
  159.       STORE64_LE(P->node_offset, 0);
  160.       P->node_depth   = 0;

crypto_pwhash/argon2/argon2-fill-block-avx512f.c:195: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `memcpy()` at line 195, column 5.
  193.       }
  194.   
  195. >     memcpy(state, ((instance->region->memory + prev_offset)->v),
  196.              ARGON2_BLOCK_SIZE);
  197.   

crypto_hash/sha256/cp/hash_sha256_cp.c:162: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `state->buf` `of size 64` could be accessed with an index out of bounds at line 162, column 13.
  160.       if (r < 56) {
  161.           for (i = 0; i < 56 - r; i++) {
  162. >             state->buf[r + i] = PAD[i];
  163.           }
  164.       } else {

crypto_hash/sha256/cp/hash_sha256_cp.c:166: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `state->buf` `of size 64` could be accessed with an index out of bounds at line 166, column 13.
  164.       } else {
  165.           for (i = 0; i < 64 - r; i++) {
  166. >             state->buf[r + i] = PAD[i];
  167.           }
  168.           SHA256_Transform(state->state, state->buf, &tmp32[0], &tmp32[64]);

crypto_core/ed25519/ref10/ed25519_ref10.c:175: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  173.       fe25519 t0;
  174.   
  175. >     fe25519_add(r->X, p->Y, p->X);
  176.       fe25519_sub(r->Y, p->Y, p->X);
  177.       fe25519_mul(r->Z, r->X, q->YplusX);

crypto_core/ed25519/ref10/ed25519_ref10.c:175: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_add()` at line 175, column 5.
  173.       fe25519 t0;
  174.   
  175. >     fe25519_add(r->X, p->Y, p->X);
  176.       fe25519_sub(r->Y, p->Y, p->X);
  177.       fe25519_mul(r->Z, r->X, q->YplusX);

crypto_hash/sha512/cp/hash_sha512_cp.c:190: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  188.           memset(&state->buf[0], 0, 112);
  189.       }
  190. >     be64enc_vect(&state->buf[112], state->count, 16);
  191.       SHA512_Transform(state->state, state->buf, &tmp64[0], &tmp64[80]);
  192.   }

crypto_hash/sha512/cp/hash_sha512_cp.c:181: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `state->buf` `of size 128` could be accessed with an index out of bounds at line 181, column 13.
  179.       if (r < 112) {
  180.           for (i = 0; i < 112 - r; i++) {
  181. >             state->buf[r + i] = PAD[i];
  182.           }
  183.       } else {

crypto_hash/sha512/cp/hash_sha512_cp.c:185: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `state->buf` `of size 128` could be accessed with an index out of bounds at line 185, column 13.
  183.       } else {
  184.           for (i = 0; i < 128 - r; i++) {
  185. >             state->buf[r + i] = PAD[i];
  186.           }
  187.           SHA512_Transform(state->state, state->buf, &tmp64[0], &tmp64[80]);

crypto_hash/sha512/cp/hash_sha512_cp.c:190: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `be64enc_vect()` at line 190, column 5.
  188.           memset(&state->buf[0], 0, 112);
  189.       }
  190. >     be64enc_vect(&state->buf[112], state->count, 16);
  191.       SHA512_Transform(state->state, state->buf, &tmp64[0], &tmp64[80]);
  192.   }

crypto_generichash/blake2b/ref/blake2b-ref.c:192: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  190.       P->fanout        = 1;
  191.       P->depth         = 1;
  192. >     STORE32_LE(P->leaf_length, 0);
  193.       STORE64_LE(P->node_offset, 0);
  194.       P->node_depth   = 0;

crypto_generichash/blake2b/ref/blake2b-ref.c:192: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `store32_le()` at line 192, column 5.
  190.       P->fanout        = 1;
  191.       P->depth         = 1;
  192. >     STORE32_LE(P->leaf_length, 0);
  193.       STORE64_LE(P->node_offset, 0);
  194.       P->node_depth   = 0;

crypto_generichash/blake2b/ref/blake2b-ref.c:192: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  190.       P->fanout        = 1;
  191.       P->depth         = 1;
  192. >     STORE32_LE(P->leaf_length, 0);
  193.       STORE64_LE(P->node_offset, 0);
  194.       P->node_depth   = 0;

crypto_hash/sha256/cp/hash_sha256_cp.c:205: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `state->buf` `of size 64` could be accessed with an index out of bounds at line 205, column 13.
  203.       if (inlen < 64 - r) {
  204.           for (i = 0; i < inlen; i++) {
  205. >             state->buf[r + i] = in[i];
  206.           }
  207.           return 0;

crypto_hash/sha256/cp/hash_sha256_cp.c:210: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `state->buf` `of size 64` could be accessed with an index out of bounds at line 210, column 9.
  208.       }
  209.       for (i = 0; i < 64 - r; i++) {
  210. >         state->buf[r + i] = in[i];
  211.       }
  212.       SHA256_Transform(state->state, state->buf, &tmp32[0], &tmp32[64]);

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:218: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `padded` `of size 16` could be accessed with an index out of bounds at line 218, column 13.
  216.           memset(padded, 0, 16);
  217.           for (i = 0; i < xlen; i++) {
  218. >             padded[i] = a[i];
  219.           }
  220.           A = _mm_load_si128((const __m128i *) padded);

crypto_pwhash/argon2/argon2.c:212: warning: ANALYSIS_STOPS (biabduction/Rearrange.ml:265:38-45:)
  exception: Bad_footprint.
  210.       memset(&ctx, 0, sizeof ctx);
  211.   
  212. >     ctx.pwd       = NULL;
  213.       ctx.pwdlen    = 0;
  214.       ctx.secret    = NULL;

crypto_pwhash/argon2/argon2.c:212: error: Bad_footprint (biabduction/Rearrange.ml:265:38-45:)
  .
  210.       memset(&ctx, 0, sizeof ctx);
  211.   
  212. >     ctx.pwd       = NULL;
  213.       ctx.pwdlen    = 0;
  214.       ctx.secret    = NULL;

randombytes/randombytes.c:206: error: STACK_VARIABLE_ADDRESS_ESCAPE (biabduction/interproc.ml:529:62-69:)
  Address of stack variable `randombytes_sysrandom_implementation` escapes to implementation at line 206, column 1.
  204.       assert(buf_len <= SIZE_MAX);
  205.       randombytes_buf(buf, (size_t) buf_len);
  206. > }

sodium/core.c:216: warning: ANALYSIS_STOPS (biabduction/BuiltinDefn.ml:446:67-74:)
  exception: PRECONDITION_NOT_FOUND.
  214.       }
  215.   /* LCOV_EXCL_START */
  216. >     abort();
  217.   }
  218.   /* LCOV_EXCL_STOP */

sodium/core.c:216: error: PRECONDITION_NOT_FOUND (biabduction/BuiltinDefn.ml:446:67-74:)
  abort.
  214.       }
  215.   /* LCOV_EXCL_START */
  216. >     abort();
  217.   }
  218.   /* LCOV_EXCL_STOP */

crypto_hash/sha512/cp/hash_sha512_cp.c:233: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `state->buf` `of size 128` could be accessed with an index out of bounds at line 233, column 13.
  231.       if (inlen < 128 - r) {
  232.           for (i = 0; i < inlen; i++) {
  233. >             state->buf[r + i] = in[i];
  234.           }
  235.           return 0;

crypto_hash/sha512/cp/hash_sha512_cp.c:238: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `state->buf` `of size 128` could be accessed with an index out of bounds at line 238, column 9.
  236.       }
  237.       for (i = 0; i < 128 - r; i++) {
  238. >         state->buf[r + i] = in[i];
  239.       }
  240.       SHA512_Transform(state->state, state->buf, &tmp64[0], &tmp64[80]);

crypto_generichash/blake2b/ref/blake2b-ref.c:230: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  228.       P->fanout        = 1;
  229.       P->depth         = 1;
  230. >     STORE32_LE(P->leaf_length, 0);
  231.       STORE64_LE(P->node_offset, 0);
  232.       P->node_depth   = 0;

crypto_generichash/blake2b/ref/blake2b-ref.c:230: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `store32_le()` at line 230, column 5.
  228.       P->fanout        = 1;
  229.       P->depth         = 1;
  230. >     STORE32_LE(P->leaf_length, 0);
  231.       STORE64_LE(P->node_offset, 0);
  232.       P->node_depth   = 0;

crypto_generichash/blake2b/ref/blake2b-ref.c:230: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  228.       P->fanout        = 1;
  229.       P->depth         = 1;
  230. >     STORE32_LE(P->leaf_length, 0);
  231.       STORE64_LE(P->node_offset, 0);
  232.       P->node_depth   = 0;

crypto_pwhash/argon2/argon2-encoding.c:221: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `tmp` `of size 10` could be accessed with an index out of bounds at line 221, column 9.
  219.       i = sizeof tmp;
  220.       do {
  221. >         tmp[--i] = (x % (uint32_t) 10U) + '0';
  222.           x /= (uint32_t) 10U;
  223.       } while (x != 0U && i != 0U);

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:247: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  245.   
  246.           /* 4: X <-- H(X) */
  247. >         blockmix_salsa8(X, Y, Z, r);
  248.   
  249.           /* 3: V_i <-- X */

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:243: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `blkcpy()` at line 243, column 9.
  241.       for (i = 0; i < N; i += 2) {
  242.           /* 3: V_i <-- X */
  243. >         blkcpy((escrypt_block_t *) &V[i * (32 * r)], (escrypt_block_t *) X,
  244.                  128 * r);
  245.   

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:247: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `blockmix_salsa8()` at line 247, column 9.
  245.   
  246.           /* 4: X <-- H(X) */
  247. >         blockmix_salsa8(X, Y, Z, r);
  248.   
  249.           /* 3: V_i <-- X */

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:243: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  241.       for (i = 0; i < N; i += 2) {
  242.           /* 3: V_i <-- X */
  243. >         blkcpy((escrypt_block_t *) &V[i * (32 * r)], (escrypt_block_t *) X,
  244.                  128 * r);
  245.   

crypto_pwhash/scryptsalsa208sha256/pwhash_scryptsalsa208sha256.c:235: error: DEAD_STORE
  The value written to &ret (type int) is never used.
  233.       char            wanted[crypto_pwhash_scryptsalsa208sha256_STRBYTES];
  234.       escrypt_local_t escrypt_local;
  235. >     int             ret = -1;
  236.   
  237.       if (memchr(str, 0, crypto_pwhash_scryptsalsa208sha256_STRBYTES) !=

crypto_hash/sha256/cp/hash_sha256_cp.c:237: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `sodium_memzero()` at line 237, column 5.
  235.       SHA256_Pad(state, tmp32);
  236.       be32enc_vect(out, state->state, 32);
  237. >     sodium_memzero((void *) tmp32, sizeof tmp32);
  238.       sodium_memzero((void *) state, sizeof *state);
  239.   

crypto_core/ed25519/ref10/ed25519_ref10.c:247: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  245.       fe25519_sq(u, h->Y);
  246.       fe25519_mul(v, u, d);
  247. >     fe25519_sub(u, u, h->Z); /* u = y^2-1 */
  248.       fe25519_add(v, v, h->Z); /* v = dy^2+1 */
  249.   

crypto_core/ed25519/ref10/ed25519_ref10.c:247: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_sub()` at line 247, column 5.
  245.       fe25519_sq(u, h->Y);
  246.       fe25519_mul(v, u, d);
  247. >     fe25519_sub(u, u, h->Z); /* u = y^2-1 */
  248.       fe25519_add(v, v, h->Z); /* v = dy^2+1 */
  249.   

crypto_pwhash/argon2/pwhash_argon2i.c:260: warning: ANALYSIS_STOPS (biabduction/Rearrange.ml:265:38-45:)
  exception: Bad_footprint.
  258.           return -1; /* LCOV_EXCL_LINE */
  259.       }
  260. >     ctx.out    = ctx.pwd       = ctx.salt    = fodder;
  261.       ctx.outlen = ctx.pwdlen    = ctx.saltlen = (uint32_t) fodder_len;
  262.       ctx.ad     = ctx.secret    = NULL;

crypto_pwhash/argon2/pwhash_argon2i.c:260: error: Bad_footprint (biabduction/Rearrange.ml:265:38-45:)
  .
  258.           return -1; /* LCOV_EXCL_LINE */
  259.       }
  260. >     ctx.out    = ctx.pwd       = ctx.salt    = fodder;
  261.       ctx.outlen = ctx.pwdlen    = ctx.saltlen = (uint32_t) fodder_len;
  262.       ctx.ad     = ctx.secret    = NULL;

crypto_pwhash/argon2/pwhash_argon2i.c:247: error: DEAD_STORE
  The value written to &ret (type int) is never used.
  245.       argon2_context  ctx;
  246.       size_t          fodder_len;
  247. >     int             ret = -1;
  248.   
  249.       fodder_len = strlen(str);

crypto_generichash/blake2b/ref/blake2b-ref.c:272: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  270.               blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);
  271.               blake2b_compress(S, S->buf); /* Compress */
  272. >             memcpy(S->buf, S->buf + BLAKE2B_BLOCKBYTES,
  273.                      BLAKE2B_BLOCKBYTES); /* Shift buffer left */
  274.               S->buflen -= BLAKE2B_BLOCKBYTES;

crypto_generichash/blake2b/ref/blake2b-ref.c:272: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `memcpy()` at line 272, column 13.
  270.               blake2b_increment_counter(S, BLAKE2B_BLOCKBYTES);
  271.               blake2b_compress(S, S->buf); /* Compress */
  272. >             memcpy(S->buf, S->buf + BLAKE2B_BLOCKBYTES,
  273.                      BLAKE2B_BLOCKBYTES); /* Shift buffer left */
  274.               S->buflen -= BLAKE2B_BLOCKBYTES;

crypto_hash/sha512/cp/hash_sha512_cp.c:279: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:627:34-41:)
  exception: Cannot_star.
  277.       crypto_hash_sha512_init(&state);
  278.       crypto_hash_sha512_update(&state, in, inlen);
  279. >     crypto_hash_sha512_final(&state, out);
  280.   
  281.       return 0;

crypto_hash/sha512/cp/hash_sha512_cp.c:279: error: Cannot_star (biabduction/Tabulation.ml:627:34-41:)
  .
  277.       crypto_hash_sha512_init(&state);
  278.       crypto_hash_sha512_update(&state, in, inlen);
  279. >     crypto_hash_sha512_final(&state, out);
  280.   
  281.       return 0;

crypto_core/ed25519/ref10/ed25519_ref10.c:289: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  287.       fe25519_sq(u, h->Y);
  288.       fe25519_mul(v, u, d);
  289. >     fe25519_sub(u, u, h->Z); /* u = y^2-1 */
  290.       fe25519_add(v, v, h->Z); /* v = dy^2+1 */
  291.   

crypto_core/ed25519/ref10/ed25519_ref10.c:289: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_sub()` at line 289, column 5.
  287.       fe25519_sq(u, h->Y);
  288.       fe25519_mul(v, u, d);
  289. >     fe25519_sub(u, u, h->Z); /* u = y^2-1 */
  290.       fe25519_add(v, v, h->Z); /* v = dy^2+1 */
  291.   

crypto_generichash/blake2b/ref/blake2b-ref.c:305: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  303.           S->buflen -= BLAKE2B_BLOCKBYTES;
  304.           assert(S->buflen <= BLAKE2B_BLOCKBYTES);
  305. >         memcpy(S->buf, S->buf + BLAKE2B_BLOCKBYTES, S->buflen);
  306.       }
  307.   

crypto_generichash/blake2b/ref/blake2b-ref.c:305: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `memcpy()` at line 305, column 9.
  303.           S->buflen -= BLAKE2B_BLOCKBYTES;
  304.           assert(S->buflen <= BLAKE2B_BLOCKBYTES);
  305. >         memcpy(S->buf, S->buf + BLAKE2B_BLOCKBYTES, S->buflen);
  306.       }
  307.   

crypto_generichash/blake2b/ref/blake2b-ref.c:323: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `memcpy()` at line 323, column 5.
  321.       STORE64_LE(buffer + 8 * 6, S->h[6]);
  322.       STORE64_LE(buffer + 8 * 7, S->h[7]);
  323. >     memcpy(out, buffer, outlen); /* outlen <= BLAKE2B_OUTBYTES (64) */
  324.   
  325.       sodium_memzero(S->h, sizeof S->h);

crypto_generichash/blake2b/ref/blake2b-ref.c:325: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1166:60-67:)
  possible array out of bounds in call to `sodium_memzero()` at line 325, column 5.
  323.       memcpy(out, buffer, outlen); /* outlen <= BLAKE2B_OUTBYTES (64) */
  324.   
  325. >     sodium_memzero(S->h, sizeof S->h);
  326.       sodium_memzero(S->buf, sizeof S->buf);
  327.   

crypto_pwhash/scryptsalsa208sha256/nosse/pwhash_scryptsalsa208sha256_nosse.c:371: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `PBKDF2_SHA256()` at line 371, column 5.
  369.   
  370.       /* 5: DK <-- PBKDF2(P, B, 1, dkLen) */
  371. >     PBKDF2_SHA256(passwd, passwdlen, B, B_size, 1, buf, buflen);
  372.   
  373.       /* Success! */

crypto_pwhash/scryptsalsa208sha256/sse/pwhash_scryptsalsa208sha256_sse.c:395: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `PBKDF2_SHA256()` at line 395, column 5.
  393.   
  394.       /* 5: DK <-- PBKDF2(P, B, 1, dkLen) */
  395. >     PBKDF2_SHA256(passwd, passwdlen, B, B_size, 1, buf, buflen);
  396.   
  397.       /* Success! */

crypto_core/ed25519/ref10/ed25519_ref10.c:330: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  328.       fe25519 t0;
  329.   
  330. >     fe25519_add(r->X, p->Y, p->X);
  331.       fe25519_sub(r->Y, p->Y, p->X);
  332.       fe25519_mul(r->Z, r->X, q->yplusx);

crypto_core/ed25519/ref10/ed25519_ref10.c:330: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_add()` at line 330, column 5.
  328.       fe25519 t0;
  329.   
  330. >     fe25519_add(r->X, p->Y, p->X);
  331.       fe25519_sub(r->Y, p->Y, p->X);
  332.       fe25519_mul(r->Z, r->X, q->yplusx);

crypto_core/ed25519/ref10/ed25519_ref10.c:351: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  349.       fe25519 t0;
  350.   
  351. >     fe25519_add(r->X, p->Y, p->X);
  352.       fe25519_sub(r->Y, p->Y, p->X);
  353.       fe25519_mul(r->Z, r->X, q->yminusx);

crypto_core/ed25519/ref10/ed25519_ref10.c:351: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_add()` at line 351, column 5.
  349.       fe25519 t0;
  350.   
  351. >     fe25519_add(r->X, p->Y, p->X);
  352.       fe25519_sub(r->Y, p->Y, p->X);
  353.       fe25519_mul(r->Z, r->X, q->yminusx);

crypto_core/ed25519/ref10/ed25519_ref10.c:370: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  368.   ge25519_p1p1_to_p2(ge25519_p2 *r, const ge25519_p1p1 *p)
  369.   {
  370. >     fe25519_mul(r->X, p->X, p->T);
  371.       fe25519_mul(r->Y, p->Y, p->Z);
  372.       fe25519_mul(r->Z, p->Z, p->T);

crypto_core/ed25519/ref10/ed25519_ref10.c:370: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_mul()` at line 370, column 5.
  368.   ge25519_p1p1_to_p2(ge25519_p2 *r, const ge25519_p1p1 *p)
  369.   {
  370. >     fe25519_mul(r->X, p->X, p->T);
  371.       fe25519_mul(r->Y, p->Y, p->Z);
  372.       fe25519_mul(r->Z, p->Z, p->T);

crypto_core/ed25519/ref10/ed25519_ref10.c:382: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  380.   ge25519_p1p1_to_p3(ge25519_p3 *r, const ge25519_p1p1 *p)
  381.   {
  382. >     fe25519_mul(r->X, p->X, p->T);
  383.       fe25519_mul(r->Y, p->Y, p->Z);
  384.       fe25519_mul(r->Z, p->Z, p->T);

crypto_core/ed25519/ref10/ed25519_ref10.c:382: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_mul()` at line 382, column 5.
  380.   ge25519_p1p1_to_p3(ge25519_p3 *r, const ge25519_p1p1 *p)
  381.   {
  382. >     fe25519_mul(r->X, p->X, p->T);
  383.       fe25519_mul(r->Y, p->Y, p->Z);
  384.       fe25519_mul(r->Z, p->Z, p->T);

crypto_core/ed25519/ref10/ed25519_ref10.c:408: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  406.       fe25519_sq(r->Z, p->Y);
  407.       fe25519_sq2(r->T, p->Z);
  408. >     fe25519_add(r->Y, p->X, p->Y);
  409.       fe25519_sq(t0, r->Y);
  410.       fe25519_add(r->Y, r->Z, r->X);

crypto_core/ed25519/ref10/ed25519_ref10.c:408: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_add()` at line 408, column 5.
  406.       fe25519_sq(r->Z, p->Y);
  407.       fe25519_sq2(r->T, p->Z);
  408. >     fe25519_add(r->Y, p->X, p->Y);
  409.       fe25519_sq(t0, r->Y);
  410.       fe25519_add(r->Y, r->Z, r->X);

sodium/utils.c:444: warning: ANALYSIS_STOPS (biabduction/BuiltinDefn.ml:446:67-74:)
  exception: PRECONDITION_NOT_FOUND.
  442.       raise(SIGKILL);
  443.   # endif
  444. >     abort(); /* not something we want any higher-level API to catch */
  445.   } /* LCOV_EXCL_LINE */
  446.   

sodium/utils.c:444: error: PRECONDITION_NOT_FOUND (biabduction/BuiltinDefn.ml:446:67-74:)
  abort.
  442.       raise(SIGKILL);
  443.   # endif
  444. >     abort(); /* not something we want any higher-level API to catch */
  445.   } /* LCOV_EXCL_LINE */
  446.   

crypto_core/ed25519/ref10/ed25519_ref10.c:441: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  439.   ge25519_p3_to_cached(ge25519_cached *r, const ge25519_p3 *p)
  440.   {
  441. >     fe25519_add(r->YplusX, p->Y, p->X);
  442.       fe25519_sub(r->YminusX, p->Y, p->X);
  443.       fe25519_copy(r->Z, p->Z);

crypto_core/ed25519/ref10/ed25519_ref10.c:441: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_add()` at line 441, column 5.
  439.   ge25519_p3_to_cached(ge25519_cached *r, const ge25519_p3 *p)
  440.   {
  441. >     fe25519_add(r->YplusX, p->Y, p->X);
  442.       fe25519_sub(r->YminusX, p->Y, p->X);
  443.       fe25519_copy(r->Z, p->Z);

crypto_pwhash/argon2/argon2-core.c:493: error: MEMORY_LEAK (biabduction/Abs.ml:1092:18-25:)
  memory dynamically allocated by call to `malloc()` at line 487, column 10 is not reachable after line 493, column 9.
  491.       result = allocate_memory(&(instance->region), instance->memory_blocks);
  492.       if (ARGON2_OK != result) {
  493. >         free_instance(instance, context->flags);
  494.           return result;
  495.       }

randombytes/salsa20/randombytes_salsa20_random.c:481: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `key` `of size 32` last assigned on line 477 could be accessed with an index out of bounds at line 481, column 9.
  479.   
  480.       for (i = (size_t) 0U; i < sizeof stream.key; i++) {
  481. >         key[i] ^= mix[i];
  482.       }
  483.   }

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:526: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  524.   
  525.       (void) nsec;
  526. >     memcpy(H, ctx->H, sizeof H);
  527.       if (mlen > crypto_aead_aes256gcm_MESSAGEBYTES_MAX) {
  528.           sodium_misuse(); /* LCOV_EXCL_LINE */

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:526: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `memcpy()` at line 526, column 5.
  524.   
  525.       (void) nsec;
  526. >     memcpy(H, ctx->H, sizeof H);
  527.       if (mlen > crypto_aead_aes256gcm_MESSAGEBYTES_MAX) {
  528.           sodium_misuse(); /* LCOV_EXCL_LINE */

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:545: error: DEAD_STORE
  The value written to &H4v (type void) is never used.
  543.       H2v = mulv(Hv, Hv);
  544.       H3v = mulv(H2v, Hv);
  545. >     H4v = mulv(H3v, Hv);
  546.   
  547.       accv = _mm_setzero_si128();

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:609: error: DEAD_STORE
  The value written to &lb (type int) is never used.
  607.       n2[3] &= 0x00ffffff;
  608.       COUNTER_INC2(n2);
  609. >     LOOPRND128;
  610.       LOOPRMD128;
  611.   

crypto_core/ed25519/ref10/ed25519_ref10.c:619: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  617.       fe25519 t0;
  618.   
  619. >     fe25519_add(r->X, p->Y, p->X);
  620.       fe25519_sub(r->Y, p->Y, p->X);
  621.       fe25519_mul(r->Z, r->X, q->YminusX);

crypto_core/ed25519/ref10/ed25519_ref10.c:619: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_add()` at line 619, column 5.
  617.       fe25519 t0;
  618.   
  619. >     fe25519_add(r->X, p->Y, p->X);
  620.       fe25519_sub(r->Y, p->Y, p->X);
  621.       fe25519_mul(r->Z, r->X, q->YminusX);

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:687: error: DEAD_STORE
  The value written to &H4v (type void) is never used.
  685.       H2v = mulv(Hv, Hv);
  686.       H3v = mulv(H2v, Hv);
  687. >     H4v = mulv(H3v, Hv);
  688.   
  689.       accv = _mm_setzero_si128();

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:772: error: DEAD_STORE
  The value written to &lb (type int) is never used.
  770.   
  771.       COUNTER_INC2(n2);
  772. >     LOOPACCUMDRND128;
  773.       LOOPACCUMDRMD128;
  774.       addmul(accum, fb, 16, H);

crypto_core/ed25519/ref10/ed25519_ref10.c:679: error: Assert_failure (biabduction/Absarray.ml:579:2-2:)
  .
  677.       ge25519_p3_to_cached(&Ai[0], A);
  678.   
  679. >     ge25519_p3_dbl(&t, A);
  680.       ge25519_p1p1_to_p3(&A2, &t);
  681.   

sodium/utils.c:699: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION (biabduction/SymExec.ml:406:77-84:)
  A unary minus is applied to `expression i` of type unsigned long at line 699, column 9.
  697.       for (i = 0; i < blocksize; i++) {
  698.           barrier_mask = (unsigned char) (((i ^ xpadlen) - 1U) >> 8);
  699. >         tail[-i] = (tail[-i] & mask) | (0x80 & barrier_mask);
  700.           mask |= barrier_mask;
  701.       }

sodium/utils.c:699: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION (biabduction/SymExec.ml:406:77-84:)
  A unary minus is applied to `expression i` of type unsigned long at line 699, column 9.
  697.       for (i = 0; i < blocksize; i++) {
  698.           barrier_mask = (unsigned char) (((i ^ xpadlen) - 1U) >> 8);
  699. >         tail[-i] = (tail[-i] & mask) | (0x80 & barrier_mask);
  700.           mask |= barrier_mask;
  701.       }

sodium/utils.c:699: error: ARRAY_OUT_OF_BOUNDS_L1 (biabduction/Rearrange.ml:63:68-75:)
  array `tail` last assigned on line 692 could be accessed with index -1 out of bounds at line 699, column 9.
  697.       for (i = 0; i < blocksize; i++) {
  698.           barrier_mask = (unsigned char) (((i ^ xpadlen) - 1U) >> 8);
  699. >         tail[-i] = (tail[-i] & mask) | (0x80 & barrier_mask);
  700.           mask |= barrier_mask;
  701.       }

sodium/utils.c:699: error: ARRAY_OUT_OF_BOUNDS_L1 (biabduction/Rearrange.ml:63:68-75:)
  array `tail` last assigned on line 692 could be accessed with index -1 out of bounds at line 699, column 9.
  697.       for (i = 0; i < blocksize; i++) {
  698.           barrier_mask = (unsigned char) (((i ^ xpadlen) - 1U) >> 8);
  699. >         tail[-i] = (tail[-i] & mask) | (0x80 & barrier_mask);
  700.           mask |= barrier_mask;
  701.       }

sodium/utils.c:723: warning: UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION (biabduction/SymExec.ml:406:77-84:)
  A unary minus is applied to `expression i` of type unsigned long at line 723, column 13.
  721.   
  722.       for (i = 0U; i < blocksize; i++) {
  723. >         c = tail[-i];
  724.           is_barrier =
  725.               (( (acc - 1U) & (pad_len - 1U) & ((c ^ 0x80) - 1U) ) >> 8) & 1U;

sodium/utils.c:723: error: ARRAY_OUT_OF_BOUNDS_L1 (biabduction/Rearrange.ml:63:68-75:)
  array `tail` last assigned on line 720 could be accessed with index -1 out of bounds at line 723, column 13.
  721.   
  722.       for (i = 0U; i < blocksize; i++) {
  723. >         c = tail[-i];
  724.           is_barrier =
  725.               (( (acc - 1U) & (pad_len - 1U) & ((c ^ 0x80) - 1U) ) >> 8) & 1U;

crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:772: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `st->buffer` `of size 32` could be accessed with an index out of bounds at line 772, column 13.
  770.           }
  771.           for (i = 0; i < want; i++) {
  772. >             st->buffer[st->leftover + i] = m[i];
  773.           }
  774.           bytes -= want;

crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:866: warning: ANALYSIS_STOPS (biabduction/Absarray.ml:75:6-6:)
  exception: Assert_failure.
  864.       memcpy(&mac[8], &h1, 8);
  865.   
  866. >     sodium_memzero((void *) st, sizeof *st);
  867.   }
  868.   

crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:813: warning: ANALYSIS_STOPS (biabduction/Rearrange.ml:307:38-45:)
  exception: Bad_footprint.
  811.           poly1305_block_copy31(final, m, leftover);
  812.           if (leftover != 16) {
  813. >             final[leftover] = 1;
  814.           }
  815.           st->flags |=

crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:866: error: Assert_failure (biabduction/Absarray.ml:75:6-6:)
  .
  864.       memcpy(&mac[8], &h1, 8);
  865.   
  866. >     sodium_memzero((void *) st, sizeof *st);
  867.   }
  868.   

crypto_onetimeauth/poly1305/sse2/poly1305_sse2.c:813: error: Bad_footprint (biabduction/Rearrange.ml:307:38-45:)
  .
  811.           poly1305_block_copy31(final, m, leftover);
  812.           if (leftover != 16) {
  813. >             final[leftover] = 1;
  814.           }
  815.           st->flags |=

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:839: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  837.       CRYPTO_ALIGN(16) crypto_aead_aes256gcm_state ctx;
  838.   
  839. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  840.   
  841.       return crypto_aead_aes256gcm_encrypt_detached_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:839: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `crypto_aead_aes256gcm_beforenm()` at line 839, column 5.
  837.       CRYPTO_ALIGN(16) crypto_aead_aes256gcm_state ctx;
  838.   
  839. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  840.   
  841.       return crypto_aead_aes256gcm_encrypt_detached_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:839: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  837.       CRYPTO_ALIGN(16) crypto_aead_aes256gcm_state ctx;
  838.   
  839. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  840.   
  841.       return crypto_aead_aes256gcm_encrypt_detached_afternm

crypto_core/ed25519/ref10/ed25519_ref10.c:855: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `e` `of size 64` could be accessed with an index out of bounds at line 855, column 9.
  853.   
  854.       for (i = 0; i < 32; ++i) {
  855. >         e[2 * i + 0] = (a[i] >> 0) & 15;
  856.           e[2 * i + 1] = (a[i] >> 4) & 15;
  857.       }

crypto_core/ed25519/ref10/ed25519_ref10.c:856: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `e` `of size 64` could be accessed with an index out of bounds at line 856, column 9.
  854.       for (i = 0; i < 32; ++i) {
  855.           e[2 * i + 0] = (a[i] >> 0) & 15;
  856. >         e[2 * i + 1] = (a[i] >> 4) & 15;
  857.       }
  858.       /* each e[i] is between 0 and 15 */

crypto_core/ed25519/ref10/ed25519_ref10.c:863: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `e` `of size 64` could be accessed with an index out of bounds at line 863, column 9.
  861.       carry = 0;
  862.       for (i = 0; i < 63; ++i) {
  863. >         e[i] += carry;
  864.           carry = e[i] + 8;
  865.           carry >>= 4;

crypto_core/ed25519/ref10/ed25519_ref10.c:874: warning: ARRAY_OUT_OF_BOUNDS_L3 (biabduction/Rearrange.ml:71:54-61:)
  array `e` `of size 64` could be accessed with an index out of bounds at line 874, column 40.
  872.   
  873.       for (i = 1; i < 64; i += 2) {
  874. >         ge25519_select_base(&t, i / 2, e[i]);
  875.           ge25519_madd(&r, h, &t);
  876.           ge25519_p1p1_to_p3(h, &r);

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:860: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  858.       int ret;
  859.   
  860. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  861.   
  862.       ret = crypto_aead_aes256gcm_encrypt_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:860: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `crypto_aead_aes256gcm_beforenm()` at line 860, column 5.
  858.       int ret;
  859.   
  860. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  861.   
  862.       ret = crypto_aead_aes256gcm_encrypt_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:860: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  858.       int ret;
  859.   
  860. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  861.   
  862.       ret = crypto_aead_aes256gcm_encrypt_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:883: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  881.       CRYPTO_ALIGN(16) crypto_aead_aes256gcm_state ctx;
  882.   
  883. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  884.   
  885.       return crypto_aead_aes256gcm_decrypt_detached_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:883: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `crypto_aead_aes256gcm_beforenm()` at line 883, column 5.
  881.       CRYPTO_ALIGN(16) crypto_aead_aes256gcm_state ctx;
  882.   
  883. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  884.   
  885.       return crypto_aead_aes256gcm_decrypt_detached_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:883: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  881.       CRYPTO_ALIGN(16) crypto_aead_aes256gcm_state ctx;
  882.   
  883. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  884.   
  885.       return crypto_aead_aes256gcm_decrypt_detached_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:904: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  902.       int ret;
  903.   
  904. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  905.   
  906.       ret = crypto_aead_aes256gcm_decrypt_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:904: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `crypto_aead_aes256gcm_beforenm()` at line 904, column 5.
  902.       int ret;
  903.   
  904. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  905.   
  906.       ret = crypto_aead_aes256gcm_decrypt_afternm

crypto_aead/aes256gcm/aesni/aead_aes256gcm_aesni.c:904: error: Abduction_case_not_implemented (biabduction/Prover.ml:1577:55-62:)
  .
  902.       int ret;
  903.   
  904. >     crypto_aead_aes256gcm_beforenm(&ctx, k);
  905.   
  906.       ret = crypto_aead_aes256gcm_decrypt_afternm

crypto_core/ed25519/ref10/ed25519_ref10.c:964: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  962.       fe25519_sq(z2, p->Z);
  963.       fe25519_sub(t0, y2, x2);
  964. >     fe25519_mul(t0, t0, z2);
  965.   
  966.       fe25519_mul(t1, x2, y2);

crypto_core/ed25519/ref10/ed25519_ref10.c:964: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_mul()` at line 964, column 5.
  962.       fe25519_sq(z2, p->Z);
  963.       fe25519_sub(t0, y2, x2);
  964. >     fe25519_mul(t0, t0, z2);
  965.   
  966.       fe25519_mul(t1, x2, y2);

crypto_core/ed25519/ref10/ed25519_ref10.c:1912: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  1910.       fe25519_sq(t0, t1);
  1911.       fe25519_sq(t2, t0);
  1912. >     fe25519_sq(t2, t2);
  1913.       fe25519_mul(t2, t2, t0);
  1914.       fe25519_mul(t1, t2, z);

crypto_core/ed25519/ref10/ed25519_ref10.c:1912: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_sq()` at line 1912, column 5.
  1910.       fe25519_sq(t0, t1);
  1911.       fe25519_sq(t2, t0);
  1912. >     fe25519_sq(t2, t2);
  1913.       fe25519_mul(t2, t2, t0);
  1914.       fe25519_mul(t1, t2, z);

crypto_core/ed25519/ref10/ed25519_ref10.c:1978: warning: ANALYSIS_STOPS (biabduction/Tabulation.ml:1360:58-65:)
  exception: PRECONDITION_NOT_MET.
  1976.   
  1977.       /* elligator */
  1978. >     fe25519_sq2(rr2, rr2);
  1979.       rr2[0]++;
  1980.       fe25519_invert(rr2, rr2);

crypto_core/ed25519/ref10/ed25519_ref10.c:1978: warning: PRECONDITION_NOT_MET (biabduction/Tabulation.ml:1360:58-65:)
  in call to `fe25519_sq2()` at line 1978, column 5.
  1976.   
  1977.       /* elligator */
  1978. >     fe25519_sq2(rr2, rr2);
  1979.       rr2[0]++;
  1980.       fe25519_invert(rr2, rr2);

Summary of the reports

                             ARRAY_OUT_OF_BOUNDS_L3: 61
                                     ANALYSIS_STOPS: 43
                               PRECONDITION_NOT_MET: 43
                                         DEAD_STORE: 22
                     Abduction_case_not_implemented: 9
                                UNINITIALIZED_VALUE: 7
                                      Bad_footprint: 7
   Assert_failure (biabduction/SymExec.ml:303:6-6:): 4
         UNARY_MINUS_APPLIED_TO_UNSIGNED_EXPRESSION: 3
                             ARRAY_OUT_OF_BOUNDS_L1: 3
                                        Cannot_star: 2
  Assert_failure (biabduction/Absarray.ml:579:2-2:): 2
   Assert_failure (biabduction/Absarray.ml:75:6-6:): 2
                             PRECONDITION_NOT_FOUND: 2
                      STACK_VARIABLE_ADDRESS_ESCAPE: 1
                                        MEMORY_LEAK: 1
